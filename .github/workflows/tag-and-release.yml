name: Tag and Release

on:
  workflow_run:
    workflows: ["CI Pipeline (Composite)"]
    types:
      - completed

permissions:
  contents: read
  actions: read

jobs:
  tag-and-release:
    concurrency:
      group: ${{ github.workflow }}-${{ github.event.workflow_run.head_sha }}
      cancel-in-progress: true
    permissions:
      contents: write
      actions: write
    runs-on: self-hosted-windows-lv
    steps:
      - name: Exit if upstream run not from push or failed
        if: ${{ github.event.workflow_run.conclusion != 'success' || github.event.workflow_run.event != 'push' }}
        run: |
          echo "Upstream CI run conclusion=${{ github.event.workflow_run.conclusion }}, event=${{ github.event.workflow_run.event }}. Skipping tag."
          exit 0

      - name: Enforce allowed branches
        shell: pwsh
        env:
          EXTRA_PATTERNS: ${{ env.ALLOWED_BRANCH_PATTERNS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $branch = '${{ github.event.workflow_run.head_branch }}'
          $patterns = @('main', 'develop', 'release-alpha/*', 'release-beta/*', 'release-rc/*')
          if ($Env:EXTRA_PATTERNS) {
            $patterns += $Env:EXTRA_PATTERNS.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
          }
          $isAllowed = $false
          foreach ($pat in $patterns) {
            if ($branch -like $pat) { $isAllowed = $true; break }
          }
          if (-not $isAllowed) {
            Write-Host ("Branch '{0}' not in allow-list patterns: {1}. Skipping tag-and-release (no tag/release operations executed)." -f $branch, ($patterns -join ', '))
            exit 0
          } else {
            Write-Host ("Branch '{0}' allowed by patterns: {1}." -f $branch, ($patterns -join ', '))
          }

      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Compute version
        id: version
        uses: ./.github/actions/compute-version
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Form tag
        id: form-tag
        shell: pwsh
        run: |
          $tag = "v${{ steps.version.outputs.MAJOR }}.${{ steps.version.outputs.MINOR }}.${{ steps.version.outputs.PATCH }}.${{ steps.version.outputs.BUILD }}"
          Write-Host "Tag: $tag"
          "tag=$tag" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

      - name: Check existing tag target (remote)
        id: check-tag
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $tag = "${{ steps.form-tag.outputs.tag }}"
          $remoteSha = git ls-remote --tags origin $tag | ForEach-Object { ($_ -split '\s+')[0] } | Select-Object -First 1
          if ($remoteSha) {
            Write-Host ("Tag {0} exists on origin with SHA {1}" -f $tag, $remoteSha)
          } else {
            Write-Host ("Tag {0} not found on origin." -f $tag)
          }
          "remote_tag_sha=$remoteSha" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

      - name: Fail if tag belongs to a different commit
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $tag = "${{ steps.form-tag.outputs.tag }}"
          $headSha = git rev-parse HEAD
          $existingSha = "${{ steps.check-tag.outputs.remote_tag_sha }}"
          if (-not $existingSha) {
            $existingSha = git rev-list -n 1 $tag 2>$null
          }
          if ($existingSha) {
            if ($existingSha -ne $headSha) {
              Write-Error ("Tag {0} already exists and points to {1}, not {2}. Aborting." -f $tag, $existingSha, $headSha)
            } else {
              Write-Host ("Tag {0} already exists on this commit ({1}); skipping creation." -f $tag, $existingSha)
              exit 0
            }
          }

      - name: Create tag (with retry, idempotent)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          $tag = "${{ steps.form-tag.outputs.tag }}"
          if (git rev-parse --verify --quiet $tag) {
            Write-Host "Tag $tag already exists; skipping."
            exit 0
          }
          git tag $tag
          $pushed = $false
          for ($i=0; $i -lt 3; $i++) {
            git push origin $tag
            if ($LASTEXITCODE -eq 0) {
              $pushed = $true
              break
            }
            if ($i -lt 2) {
              Write-Host "Push failed, retrying in 5 seconds... (attempt $($i + 1) of 3)"
              Start-Sleep -Seconds 5
            }
          }
          if (-not $pushed) {
            Write-Error "Failed to push tag $tag after 3 attempts."
            exit 1
          }

      - name: Download artifacts from successful run
        uses: actions/download-artifact@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
          path: artifacts

      - name: List downloaded artifacts
        shell: pwsh
        run: |
          Write-Host "Artifacts downloaded to $(Join-Path $PWD 'artifacts'):"
          Get-ChildItem -Path artifacts -Recurse | Select-Object FullName

      - name: Locate release assets from artifacts
        id: locate-artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $root = Join-Path -Path $PWD -ChildPath "artifacts"
          $vip = Get-ChildItem -Path $root -Recurse -Filter *.vip -File | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $vip) { Write-Error "No .vip found in downloaded artifacts."; exit 1 }

          $notes = Get-ChildItem -Path $root -Recurse -Filter "release_notes_*.md" -File | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $notes) { Write-Error "No release_notes_*.md found in downloaded artifacts."; exit 1 }

          $expectedVersion = "$(${{ steps.version.outputs.MAJOR }}).$(${{ steps.version.outputs.MINOR }}).$(${{ steps.version.outputs.PATCH }}).$(${{ steps.version.outputs.BUILD }})"
          if ($vip.Name -notmatch $expectedVersion) {
            Write-Error ("Located .vip '{0}' does not contain expected version '{1}'." -f $vip.Name, $expectedVersion)
          }
          if ($notes.Name -notmatch $expectedVersion) {
            Write-Error ("Located release notes '{0}' do not contain expected version '{1}'." -f $notes.Name, $expectedVersion)
          }

          "vip_path=$($vip.FullName)"     | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "vip_name=$($vip.Name)"         | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "notes_path=$($notes.FullName)" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
          "notes_name=$($notes.Name)"     | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

      - name: Create draft GitHub release and upload assets
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.form-tag.outputs.tag }}
          name: ${{ steps.form-tag.outputs.tag }}
          draft: true
          prerelease: false
          files: |
            ${{ steps.locate-artifacts.outputs.vip_path }}
            ${{ steps.locate-artifacts.outputs.notes_path }}

      - name: Publish release after assets are attached
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = '${{ steps.form-tag.outputs.tag }}';
            try {
              // If release exists, update; otherwise create then update
              let release;
              try {
                release = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.name,
                  tag: tag,
                });
              } catch (err) {
                if (err.status === 404) {
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.name,
                    tag_name: tag,
                    name: tag,
                    draft: true,
                    prerelease: false,
                  });
                } else {
                  throw err;
                }
              }

              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.name,
                release_id: release.data.id,
                draft: false,
                make_latest: true,
              });
              console.log(`Release for tag ${tag} published successfully.`);
            } catch (error) {
              console.error(`Failed to publish release for tag: ${tag}`);
              console.error(error);
              throw error;
            }
