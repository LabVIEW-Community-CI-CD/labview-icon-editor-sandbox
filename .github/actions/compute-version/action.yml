name: "Compute Version"
description: "Determines semantic version components and full version string based on branch, labels and commit count."
inputs:
  github_token:
    description: "GitHub token with repository access"
    required: true
outputs:
  VERSION:
    description: "Full version string"
    value: ${{ steps.next_version.outputs.VERSION }}
  MAJOR:
    description: "Major version"
    value: ${{ steps.next_version.outputs.MAJOR }}
  MINOR:
    description: "Minor version"
    value: ${{ steps.next_version.outputs.MINOR }}
  PATCH:
    description: "Patch version"
    value: ${{ steps.next_version.outputs.PATCH }}
  BUILD:
    description: "Commit-based build number"
    value: ${{ steps.inc_build.outputs.new_build_number }}
  IS_PRERELEASE:
    description: "Whether the version is a prerelease"
    value: ${{ steps.next_version.outputs.IS_PRERELEASE }}
runs:
  using: "composite"
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Determine bump type
      id: bump_type
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const allowed = ['major', 'minor', 'patch'];
          let bump = 'none';
          if (context.event_name === 'pull_request') {
            const labels = context.payload.pull_request.labels.map(l => l.name.toLowerCase());
            const found = labels.filter(l => allowed.includes(l));
            core.info(`PR labels: ${labels.join(', ') || '(none)'}`);
            if (found.length > 1) {
              core.setFailed(`Exactly one release label required (major/minor/patch); found: ${found.join(', ')}`);
              return;
            }
            bump = found[0] || 'patch';
            core.info(`Selected bump type: ${bump}`);
          } else {
            core.info(`Non-PR event (${context.event_name}); bump type left as '${bump}'.`);
          }
          core.setOutput('bump_type', bump);

    - name: Find last reachable tag
      id: last_tag
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        $tag = git describe --tags --abbrev=0 2>$null
        if ($LASTEXITCODE -ne 0 -or [string]::IsNullOrWhiteSpace($tag)) {
          Write-Host "No reachable tag found."
          $tag = ''
        } else {
          Write-Host "Last reachable tag: $tag"
        }
        "last_tag=$tag" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

    - name: Determine build number
      id: inc_build
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'
        git fetch --unshallow 2>$null || Write-Host "Already a full clone."
        $lastTag = "${{ steps.last_tag.outputs.last_tag }}"
        if ([string]::IsNullOrWhiteSpace($lastTag)) {
          $count = git rev-list --count HEAD
          Write-Host "No tag found; build number = commits from root => $count"
        } else {
          $count = git rev-list --count "$lastTag..HEAD"
          Write-Host "Build number = commits since tag $lastTag => $count"
        }
        Write-Host "Commit-based build number => $count"
        "new_build_number=$count" | Out-File -FilePath $Env:GITHUB_OUTPUT -Append

    - name: Compute version string
      id: next_version
      shell: pwsh
      env:
        BUMP_TYPE:    ${{ steps.bump_type.outputs.bump_type }}
        BUILD_NUMBER: ${{ steps.inc_build.outputs.new_build_number }}
        LAST_TAG:     ${{ steps.last_tag.outputs.last_tag }}
      run: |
        $latestRaw = git describe --tags --abbrev=0 2>$null
        if ($LASTEXITCODE -ne 0) {
          Write-Host "No existing tags were found; defaulting to base 0.1.0."
          $latestRaw = ''
          $global:LASTEXITCODE = 0
        }
        if ([string]::IsNullOrWhiteSpace($latestRaw)) {
          $maj=0; $min=1; $pat=0
        }
        else {
          $latest = $env:LAST_TAG
          $latest = $latest.Trim().TrimStart('v') -replace '-build.*'
          $parts = $latest.Split('.')
          $maj = if ($parts.Length -gt 0 -and $parts[0]) { [int]$parts[0] } else { 0 }
          $min = if ($parts.Length -gt 1 -and $parts[1]) { [int]$parts[1] } else { 0 }
          $pat = if ($parts.Length -gt 2 -and $parts[2]) { [int]$parts[2] } else { 0 }
        }
        switch ($env:BUMP_TYPE) {
          'major' { $maj++; $min=0; $pat=0 }
          'minor' { $min++; $pat=0 }
          'patch' { $pat++ }
        }
        $branch = $Env:GITHUB_REF -replace '^refs/heads/',''
        $suffix = ''
        if ($branch -like 'release-alpha/*') { $suffix = "alpha.$($Env:BUILD_NUMBER)" }
        elseif ($branch -like 'release-beta/*')  { $suffix = "beta.$($Env:BUILD_NUMBER)" }
        elseif ($branch -like 'release-rc/*')    { $suffix = "rc.$($Env:BUILD_NUMBER)" }
        $version = if ($suffix) { "v$maj.$min.$pat-$suffix-build$($Env:BUILD_NUMBER)" } else { "v$maj.$min.$pat-build$($Env:BUILD_NUMBER)" }
        $isPre  = if ($suffix) { 'true' } else { 'false' }
        Write-Host "Computed version => $version"
        "VERSION=$version"      | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
        "MAJOR=$maj"            | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
        "MINOR=$min"            | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
        "PATCH=$pat"            | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
        "IS_PRERELEASE=$isPre"  | Out-File -FilePath $Env:GITHUB_OUTPUT -Append
